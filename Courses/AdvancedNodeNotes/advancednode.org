#+TITLE: Stephen Grider Advanced Node Course Notes
#+AUTHOR: @tomcatfever
#+CATEGORY: Courses 
#+STARTUP: content
#+STARTUP: indent 
#+SEQ_TODO: TODO CURRENT SOMEDAY | DONE CANCEL
* Advanced Node Course
* Tasks
** DONE Part One: The Internals of Node 
CLOSED: [2018-05-22 Tue 11:20]
*** DONE Configure local project for examples with eslint and babel properly
CLOSED: [2018-05-21 Mon 12:05]
*** DONE Connect Visual Studio Code with eslint
CLOSED: [2018-05-21 Mon 12:07]
*** DONE Configure Spacemacs React layer
CLOSED: [2018-05-21 Mon 12:05]
*** DONE Advance Node Course: Part one screenshots
CLOSED: [2018-05-21 Mon 12:32]
** CURRENT Part Two: Enhancing Node Performance 
*** DONE Add to outline and summarize lectures. 
CLOSED: [2018-05-22 Tue 11:30]
** Part Three: Project Setup 
   - 5 Lectures 
   - 00:24:45 time
** Part Four: Data Caching with Redis 
   - 28 Lectures
   - 02:50:24 time
** Part Five: Automated Headless Browser Testing 
   - 53 Lectures 
   - 05:54:12 time
** Part Six: Wiring Up Continuous Integration 
   - 15 Lectures 
   - 01:19:36 time
** Part Seven: Scalable Image/File Upload 
   - 30 Lectures 
   - 02:20:33 time
** TODO Clean Up
*** TODO Resize and insert screen-shots
*** TODO Connect Spacemacs flycheck with local eslint directory 
*** TODO Outside of course: Set up orgmode calendar
*** SOMEDAY Craft into blog post
* Part One: The Internals of Node
** NodeJS, V8, and libuv
*First Takeaways*
- V8 Engine allows us to execute JS code outside of the browser.
- Libuv is a C++ project that give access to the file system, networking,
  and some parts of concurrency.
- NodeJS provides a javascript interface and API that allows us to use V8 
  and libuv.
- All the javascript code is in the lib directory on node's github page.
- The c++ code is in the src directory.

:ImageBasicNodeParts:
#+CAPTION: This is an image of the basic part of node.
[[./img/node-parts-simple.png]]
:END:

:ImageCryptoPath:
#+CAPTION: Introduces http fs crypto and path, lecture 9636088
[[./img/node-parts-simple-2.png]]
:END:

:ImageProcessBinding:
#+CAPTION: The process.binding() function connects a node function to V8 engine
[[./img/node-process.binding.png]]
:END:

- Once again, in NodeJS:
  - V8 is used to interpret and execute Javascript code, while
  - libuv is used for accessing the filesystem and some aspects of concurrency.

** Event Loop And Threads
*** What Are Threads?
:ImageOsxActivityMonitor:
#+CAPTION: This shows the OSX activity monitor.
[[./img/activity-monitor-threads.png]]
:END:
:ImageScheduling:
#+CAPTION: Scheduling is how a computer decides which thread to process.
[[./img/thread-scheduling.png]]
:END:
:ImageMultiCoreThreading:
#+CAPTION: To process more thread, engineers can schedule using more CPU cores, aka multi-threading or hyper-threading.
[[./img/thread-cpu-core.png]]
:END:
*** Introducing The Event Loop
*Next Takeaways*
  - Understanding the event loop will enables you to understand performance issues in NodeJS.
  - The event loop is difficult to understand.

/The image and pseudo-code examples will illustrate./

:ImageThreadEventLoop:
#+CAPTION: This visualizes how the 'event loop' handles threading in a NodeJS program.
[[./img/node-thread-loop.png]]
:END:

:PseudoCodeExample:
#+BEGIN_SRC js
// Node myFile JS
// These arrays simulate book-keeping operations.
const pendingTimers = [];
const pendingOSTasks = [];
const pendingOperations = [];

// New timers, tasks, operaitons are recorded from myFile running
myFile.runContents();

// Helper function - While loop continues for another tick.
// This describes the three pending checks NodeJS makes. 
function shouldContinue() {
  // Check One: Any pending setTimeout, setInterval, or setImmediate?
  // Check Two: Any pending OS tasks? (Like a server listening on a port)
  // Check Three: Any pending long running operations? (Like fs module) 
  return pendingTimers.length || pendingOSTasks.length || pendingOperations.length
}

// Remember while loops continue while(bool=true). In this example,
// the entire body executes in one 'tick' (is one iteration of Event Loop).

while(shouldContinue()) {
 // 1) Node looks at pendingTimers and sees if any functions are ready to be called.
 //    This involves the built in NodeJS functions setTimeout, setInterval.

 // 2) Node looks at pendingOSTasks and pendingOperations and calls relevant callbacks

 // 3) Pause execution. Continue when...
 //    - a new pendingOSTasks is done,
 //    - a new pendingOperation is done, or
 //    - a timer is about to complete. 

 // 4) Look at pendingTimers. Call any setImmediate.

 // 5) Handle any 'close' events.
}
// exit back to terminal
#+END_SRC
:END:

*** Event Loop: Single Threaded?
/In general, the NodeJS:/
*Event Loop* => Single Threaded

/However, some of NodeJS:/
*Framework/Std Lib => *Not* Single Threaded
**** Thread Pool Code Example
[[https://www.udemy.com/advanced-node-for-developers/learn/v4/t/lecture/?start=963611215][Course Link: Diagram of how node is actually threaded]]
Brief
Basically libuv creates a thread pool of calculation intensive methods like pbkdf2 which run separately.  NodeJS defaults to 4 threads as shown in the diagram. As a result the code example returns this result:
:threads:
#+BEGIN_SRC sh
$ node threads.js
2: 1047
1: 1052
#+END_SRC
:END:

Four calls are allocated to each of the default four threads:

:defaultThreads:
#+BEGIN_SRC sh
$ node threads.js
2: 2102
1: 2108
3: 2108
4: 2114
#+END_SRC
:END:

Notice that it takes a second longer?  Try with five calls:

:fiveThreads:
#+BEGIN_SRC sh
node threads.js
3: 2115
4: 2122
2: 2127
1: 2140
5: 3205
#+END_SRC
:END:

[[https://www.udemy.com/advanced-node-for-developers/learn/v4/t/lecture/?start=9636118150][Course Link: How node threads use CPU cores]]
A standard Macbook has two CPU cores.

/insert How node threads use CPU cores screenshot/

The CPU has access to multi-threading.  Therefore, each call is assigned to a thread. And then each thread concurrently resolves the calls. Finally the fifth call is assigned to a thread and resolved by the CPU.

The ~process.env~ method ~UV_THREADPOOL_SIZE~ controls the NodeJS thread pool.

#+BEGIN_SRC js
process.env.UV_THREADPOOL_SIZE = 2;
// ... rest of threads.js example
#+END_SRC

Result from running threads script with two threads and four calls:
:twoThreads:
#+BEGIN_SRC sh
$ node threads.js
2: 1069
1: 1074
3: 2141
4: 2153
5: 3181
#+END_SRC

:END:

To further test this I tried seeing the result of the following:

*1st* /Twelve calls with FOUR threads, two cores:/
:FOUR:
#+BEGIN_SRC sh
node threads.js
1: 2089
4: 2121
2: 2141
3: 2152
6: 4236
7: 4242
9: 4268
8: 4346
10: 5810
11: 5868
12 5883
#+END_SRC
:END:

*2nd* /Twelve calls with SIX threads, two cores:/
:SIX:
#+BEGIN_SRC sh
node threads.js
3: 3152
1: 3157
6: 3164
2: 3188
7: 3196
4: 3209
9: 6012
8: 6026
10: 6030
11: 6036
12 6036
#+END_SRC
:END:

**** [[https://www.udemy.com/advanced-node-for-developers/learn/v4/t/lecture/9646726?start=0][Thread Pool Faq Lesson]] 
/Insert image: ThreadPool FAQ/
*** Pending OS Tasks
This code benchmarks how the asyncronous library https handles sending a response call to google.com.  Then prints it to the NodeJS REPL.

:HttpsFirstExample:
#+BEGIN_SRC js
const https = require('https');
const start = Date.now();

function doRequest() {
    https.request('https://www.google.com', res => {
            res.on('data', () => {});
            res.on('end', () => {
                console.log(Date.now() - start);
            });
        })
        .end();
}

doRequest();
#+End_SRC
:END:

This return a response of seconds to the NodeJS console. What is returned when this function is called more than once?

:Call5Times:
#+BEGIN_SRC sh
node async.js
445
448
561
562
563
563
#+END_SRC
:end:

[[https://www.udemy.com/advanced-node-for-developers/learn/v4/t/lecture/9646730?start=100][Course Link: What happens when running ascync.js example 5x]]
*Summary*
NodeJS delegates ascync operations to the OSAscyncHelpers. *Again*, everything happens in the ThreadPool 
** Async FAQ & Review 

| Question               | Answer                           |
|------------------------+----------------------------------|
| What functions in node | Almost everything around         |
| std library use OS's   | networking for all OS's.         |
| async features?        | Some other stuff is OS specific. |
|                        |                                  |
| How does this OS       | Task using the underlying OS     |
| async stuff fit in     | are reflected in our             |
| Event Loop?            | 'pendingOSTasks' array.          |

[[https://www.udemy.com/advanced-node-for-developers/learn/v4/t/lecture/9646734?start=110][Course Link: A summary diagram]]
:ImageSummaryDiagram:
/insert screenshot of summary
:END:
* Part Two: Enhancing Node Performance  
The agenda talks about performance, children, clustering, and workers. 
* Upcoming Lecture
?
